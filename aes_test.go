package aes

import (
	"log"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMultiply(t *testing.T) {
	log.Println(Multiply(1, 5))
}
func TestAES(t *testing.T) {
	c := NewCipher(NewKey([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}))
	block := Block{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34}
	result := c.Encrypt(block)
	result = c.Decrypt(result)
	assert.Equal(t, Block{50, 67, 246, 168, 136, 90, 48, 141, 49, 49, 152, 162, 224, 55, 7, 52}, result)
}

//
// func TestAddRoundKey(t *testing.T) {
// 	state := parse(Block{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf})
// 	key := NewKey128([]byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c})
// 	schedule := ExpandKey128(key)
// 	state = addRoundKey(state, schedule, 0)
// 	log.Println(state)
// 	state = addRoundKey(state, schedule, 0)
// 	log.Println(state)
// }
//
// func TestAES_shiftRows(t *testing.T) {
// 	state := lib.NewMatrix([]byte{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf}, 4)
// 	shifted := shiftRows(state)
// 	log.Println(shifted)
// 	log.Println(shiftRowsInverse(shifted))
//
// }
//
// func TestAES_subBytes(t *testing.T) {
// 	s := lib.NewMatrix([]byte{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf}, 4)
// 	log.Println(subBytesInverse(subBytes(s)))
//
// }
//
// func TestMixColumns(t *testing.T) {
// 	s := lib.NewMatrix([]byte{0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf}, 4)
//
// 	mixed := mixColumns(s, mixColumnPolynomials)
// 	log.Println(mixed)
// 	log.Println(mixColumns(mixed, mixColumnPolynomialsInverse))
//
// 	// result := lib.NewMatrix([]byte{0x04, 0xe0, 0x48, 0x28, 0x66, 0xcb, 0xf8, 0x06, 0x81, 0x19, 0xd3, 0x26, 0xe5, 0x9a, 0x7a, 0x4c}, 4)
// }
//
// // func TestCipher(t *testing.T) {
// // 	state := lib.NewMatrix(
// // 		[]uint32{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34},
// // 		4,
// // 	).Transpose()
// // 	key := NewKey128([]byte{
// // 		0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c,
// // 	})
// //
// // }
//
// func TestKeyExpansion(t *testing.T) {
// 	key := Key128{
// 		NewWord([4]byte{0x2b, 0x7e, 0x15, 0x16}),
// 		NewWord([4]byte{0x28, 0xae, 0xd2, 0xa6}),
// 		NewWord([4]byte{0xab, 0xf7, 0x15, 0x88}),
// 		NewWord([4]byte{0x09, 0xcf, 0x4f, 0x3c}),
// 	}
// 	schedule := ExpandKey128(key)
// 	for i, k := range schedule[:40] {
// 		assert.Equal(t, NewWord(keyExpansionTestCases[i]), k)
// 	}
// }
//
// // keyExpansionTestCases are taken from FIPS-197 Appendix A.
// var keyExpansionTestCases = [][4]byte{
// 	{0x2b, 0x7e, 0x15, 0x16},
// 	{0x28, 0xae, 0xd2, 0xa6},
// 	{0xab, 0xf7, 0x15, 0x88},
// 	{0x09, 0xcf, 0x4f, 0x3c},
// 	{0xa0, 0xfa, 0xfe, 0x17},
// 	{0x88, 0x54, 0x2c, 0xb1},
// 	{0x23, 0xa3, 0x39, 0x39},
// 	{0x2a, 0x6c, 0x76, 0x05},
// 	{0xf2, 0xc2, 0x95, 0xf2},
// 	{0x7a, 0x96, 0xb9, 0x43},
// 	{0x59, 0x35, 0x80, 0x7a},
// 	{0x73, 0x59, 0xf6, 0x7f},
// 	{0x3d, 0x80, 0x47, 0x7d},
// 	{0x47, 0x16, 0xfe, 0x3e},
// 	{0x1e, 0x23, 0x7e, 0x44},
// 	{0x6d, 0x7a, 0x88, 0x3b},
// 	{0xef, 0x44, 0xa5, 0x41},
// 	{0xa8, 0x52, 0x5b, 0x7f},
// 	{0xb6, 0x71, 0x25, 0x3b},
// 	{0xdb, 0x0b, 0xad, 0x00},
// 	{0xd4, 0xd1, 0xc6, 0xf8},
// 	{0x7c, 0x83, 0x9d, 0x87},
// 	{0xca, 0xf2, 0xb8, 0xbc},
// 	{0x11, 0xf9, 0x15, 0xbc},
// 	{0x6d, 0x88, 0xa3, 0x7a},
// 	{0x11, 0x0b, 0x3e, 0xfd},
// 	{0xdb, 0xf9, 0x86, 0x41},
// 	{0xca, 0x00, 0x93, 0xfd},
// 	{0x4e, 0x54, 0xf7, 0x0e},
// 	{0x5f, 0x5f, 0xc9, 0xf3},
// 	{0x84, 0xa6, 0x4f, 0xb2},
// 	{0x4e, 0xa6, 0xdc, 0x4f},
// 	{0xea, 0xd2, 0x73, 0x21},
// 	{0xb5, 0x8d, 0xba, 0xd2},
// 	{0x31, 0x2b, 0xf5, 0x60},
// 	{0x7f, 0x8d, 0x29, 0x2f},
// 	{0xac, 0x77, 0x66, 0xf3},
// 	{0x19, 0xfa, 0xdc, 0x21},
// 	{0x28, 0xd1, 0x29, 0x41},
// 	{0x57, 0x5c, 0x00, 0x6e},
// }
